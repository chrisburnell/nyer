"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var path = _interopRequire(require("path"));

var _child_process = require("child_process");

var exec = _child_process.exec;
var spawn = _child_process.spawn;
var semver = _interopRequire(require("semver"));

var semverRegex = _interopRequire(require("semver-regex"));

var dargs = _interopRequire(require("dargs"));

var through = _interopRequire(require("through2"));

var concat = _interopRequire(require("concat-stream"));

var which = _interopRequire(require("which"));

var assign = _interopRequire(require("object-assign"));

var endsWith = _interopRequire(require("ends-with"));

var Promise = require("es6-promise").Promise;
var denodeify = _interopRequire(require("es6-denodeify"));

denodeify = denodeify(Promise);
which = denodeify(which);

var BIN = "sass-convert";
var MINVERS = ">=3.4.5";

/**
 * Execute command in a child process.
 *
 * @see {@link http://nodejs.org/api/child_process.html}
 * @param {String} command
 * @param {Array} args
 * @return {Promise}
 */
function execp(command) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var childProcess = undefined;

  return new Promise(function (resolve, reject) {
    args.push(function (err, stdout, stderr) {
      if (err) {
        assign(err, {
          message: "" + err.message + " `" + command + "` exited with error code " + err.code,
          stdout: stdout,
          stderr: stderr });

        reject(err);
      } else {
        resolve({ childProcess: childProcess, stdout: stdout, stderr: stderr });
      }
    });

    childProcess = exec.apply(undefined, [command].concat(args));
  });
}

/**
 * Custom error for binary check.
 *
 * @param {String} message
 */
var BinaryError = (function (Error) {
  function BinaryError(message) {
    _classCallCheck(this, BinaryError);

    _get(Object.getPrototypeOf(BinaryError.prototype), "constructor", this).call(this, message);
    // http://bit.ly/1yMzARU
    this.message = message || "Could not find any executable for \"" + BIN + "\". Operation Aborted.";
  }

  _inherits(BinaryError, Error);

  _prototypeProperties(BinaryError, null, {
    name: {
      get: function () {
        return "BinaryError";
      },
      configurable: true
    }
  });

  return BinaryError;
})(Error);

/**
 * Custom error for version check.
 *
 * @param {String} message
 */
var VersionError = (function (Error) {
  function VersionError(message) {
    _classCallCheck(this, VersionError);

    _get(Object.getPrototypeOf(VersionError.prototype), "constructor", this).call(this, message);
    // http://bit.ly/1yMzARU
    this.message = message || "Invalid \"" + BIN + "\" version, must be " + MINVERS;
  }

  _inherits(VersionError, Error);

  _prototypeProperties(VersionError, null, {
    name: {
      get: function () {
        return "VersionError";
      },
      configurable: true
    }
  });

  return VersionError;
})(Error);

/**
 * Check whether passed binary (Gem) is in $PATH,
 * and check its version.
 *
 * @param {String} bin
 * @return {Promise}
 */
function checkBinary(bin) {
  /**
   * Check for binary min-version.
   *
   * @param {String} str
   * @return {Boolean}
   */
  function checkVersion(str) {
    var version = str.match(semverRegex())[0];
    return semver.satisfies(version, MINVERS);
  }

  /**
   * Check for global binary and version.
   *
   * @return {Promise}
   */
  function checkGlobal() {
    return which(bin).then(function () {
      return execp("" + bin + " -v");
    }, function () {
      throw new BinaryError();
    }).then(function (res) {
      if (!checkVersion(res.stdout)) {
        throw new VersionError();
      }
    });
  }

  /**
   * Check for bundled binary and version.
   *
   * @return {Promise}
   */
  function checkBundle() {
    return which("bundle").then(function () {
      return execp("bundle exec " + bin + " -v");
    }).then(function (res) {
      if (!checkVersion(res.stdout)) {
        throw new VersionError();
      }
      return { bundler: true };
    }, function (err) {
      throw new BinaryError();
    });
  }

  return checkBundle()["catch"](checkGlobal);
}

/**
 * Run binary checks only once.
 *
 * @return {Promise}
 */
function checkBinaryCache() {
  if (!("promise" in checkBinaryCache)) {
    checkBinaryCache.promise = checkBinary(BIN);
  }

  return checkBinaryCache.promise;
}

var Converter = (function () {
  function Converter(options) {
    _classCallCheck(this, Converter);

    this.options = options || {};
    this.bundler = false;
  }

  _prototypeProperties(Converter, null, {
    command: {

      /**
       * Format the `sass-convert` command string.
       *
       * @return {Object}
       */
      value: function command() {
        var cmd = "" + (this.bundler ? "bundle exec " : "") + "sass-convert";

        // Add required args.
        var options = assign({}, this.options, {
          stdin: true,
          "no-cache": true });

        // Filter unwanted or erroneous args.
        var includes = ["from", "to", "dasherize", "indent", "old", "default-encoding", "unix-newlines", "stdin", "no-cache"];

        var args = dargs(options, { includes: includes });

        return { cmd: cmd, args: args };
      },
      writable: true,
      configurable: true
    },
    isTransformable: {

      /**
       * Returns whether file is eligible for convertion.
       *
       * @param {Object} file - Vinyl file Object
       * @return {Boolean}
       */
      value: function isTransformable(file) {
        var ext = path.extname(file.path);
        return (file.isBuffer() || file.isStream()) && endsWith(ext, this.options.from);
      },
      writable: true,
      configurable: true
    },
    convertFile: {

      /**
       * Convert file Buffer through `sass-convert` binary.
       *
       * @param {Buffer} file - Vinyl file
       * @param {String} enc - encoding
       * @return {Promise}
       */
      value: function convertFile(file, enc) {
        var _ref = this.cmdCache || (this.cmdCache = this.command());
        var cmd = _ref.cmd;
        var args = _ref.args;
        var child = spawn(cmd, args);
        var result = {};

        file.pipe(child.stdin);

        child.stdout.pipe(concat(function (data) {
          result.stdout = data;
        }));

        child.stderr.pipe(concat(function (data) {
          result.stderr = data;
        }));

        return new Promise(function (resolve, reject) {
          child.on("error", reject);

          child.on("close", function (code, signal) {
            if (code !== 0) {
              var message = "`" + cmd + " " + args.join(" ") + "` failed with code " + code;
              var stderr = Buffer.isBuffer(result.stderr) ? result.stderr.toString() : "";

              reject({ code: code, message: message, stderr: stderr });
            } else {
              resolve(result);
            }
          });
        });
      },
      writable: true,
      configurable: true
    },
    rename: {

      /**
       * Change file extension to `options.from`.
       *
       * @param {Object} file - Vinyl file
       */
      value: function rename(file) {
        if (!this.options.rename) {
          return;
        }

        var ext = path.extname(file.path);
        file.path = file.path.replace(ext, "." + this.options.to);
      },
      writable: true,
      configurable: true
    },
    stream: {

      /**
       * Returns a transform stream meant to be piped to a stream
       * of Sass, SCSS or CSS files. Apply convertion if matches.
       *
       * @return {Object} - Stream
       */
      value: function stream() {
        var self = this;

        return through.obj(function (file, enc, cb) {
          var stream = this;

          if (!self.isTransformable(file)) {
            // Pass-through.
            return cb(null, file);
          }

          // Matches `from`, let's convert it.
          checkBinaryCache().then(function (res) {
            self.bundler = res ? res.bundler : false;

            return self.convertFile(file, enc);
          }).then(function (result) {
            file.contents = new Buffer(result.stdout);
            self.rename(file);

            cb(null, file);
          }, function (err) {
            stream.emit("error", err);

            if (self.options.force) {
              // Continue stream chain,
              // but don't pass unconverted chunks.
              return cb();
            }

            // Stop stream chain.
            stream.destroy();
            stream.emit("end");
          });
        });
      },
      writable: true,
      configurable: true
    }
  });

  return Converter;
})();

module.exports = function (options) {
  return new Converter(options).stream();
};

// Expose custom error constructors.
module.exports.BinaryError = BinaryError;
module.exports.VersionError = VersionError;